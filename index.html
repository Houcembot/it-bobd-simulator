<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>It bobd - Simulateur d'Expressions Robot</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }
        
        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }
        
        #container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        #screen-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        #led-ring {
            position: absolute;
            width: 340px;
            height: 340px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            filter: blur(30px);
            opacity: 0.6;
            z-index: 0;
            transition: background 0.5s ease;
        }
        
        #canvas {
            border-radius: 50%;
            box-shadow: 
                0 0 40px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }
        
        #controls {
            background: rgba(255,255,255,0.05);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 400px;
        }
        
        h2 {
            margin-top: 0;
            color: #fff;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        button {
            padding: 15px 25px;
            font-size: 16px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #btn-kawaii { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        #btn-cyclope { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
        #btn-robot { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; }
        #btn-sunburst { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; }
        #btn-dashboard { background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); color: white; }
        #btn-myroboeyes { background: linear-gradient(135deg, #9370DB 0%, #BA55D3 100%); color: white; }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .info strong {
            color: #4facfe;
        }
        
        #mood-label {
            font-size: 1.2em;
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>ü§ñ It bobd Simulator</h1>
    <p class="subtitle">Pr√©visualisation des expressions du robot √©motionnel</p>
    
    <div id="container">
        <div id="screen-container">
            <div id="led-ring"></div>
            <canvas id="canvas" width="240" height="240"></canvas>
            <div id="mood-label">Expression: KAWAII</div>
        </div>
        
        <div id="controls">
            <h2>üé® Expressions</h2>
            <div class="btn-group">
                <button id="btn-kawaii" onclick="setExpression('kawaii')">üòä Kawaii (Yeux ronds)</button>
                <button id="btn-cyclope" onclick="setExpression('cyclope')">üëÅÔ∏è Cyclope (Un ≈ìil)</button>
                <button id="btn-robot" onclick="setExpression('robot')">ü§ñ Robot (Minimaliste)</button>
                <button id="btn-sunburst" onclick="setExpression('sunburst')">‚ú® R√©veil (Sunburst)</button>
                <button id="btn-dashboard" onclick="setExpression('dashboard')">üìä Dashboard (Stats)</button>
                <button id="btn-myroboeyes" onclick="setExpression('myroboeyes')">üëÄ Mon RoboEyes (Fid√®le)</button>
            </div>
            
            <div class="info">
                <strong>üí° Instructions :</strong><br>
                ‚Ä¢ Clique sur une expression pour la tester<br>
                ‚Ä¢ Observe les animations et couleurs LED<br>
                ‚Ä¢ Une fois valid√©es, je g√©n√®re le code ESP32<br>
                ‚Ä¢ R√©solution : 240√ó240 (GC9A01)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ledRing = document.getElementById('led-ring');
        const moodLabel = document.getElementById('mood-label');
        
        let currentExpression = 'kawaii';
        let animFrame = 0;
        let startTime = performance.now(); // Pour simuler millis()
        
        // Couleurs
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            CREAM: '#FFF8DC',
            YELLOW: '#FFD700',
            CYAN: '#00FFFF',
            MAGENTA: '#FF00FF',
            BLUE: '#4169E1',
            PINK: '#FF69B4',
            ORANGE: '#FF8C00',
            VIOLET: '#9370DB'
        };
        
        // Couleurs LED selon expression
        const LED_COLORS = {
            kawaii: 'radial-gradient(circle, rgba(102,126,234,0.8) 0%, rgba(118,75,162,0.4) 100%)',
            cyclope: 'radial-gradient(circle, rgba(255,105,180,0.8) 0%, rgba(255,20,147,0.4) 100%)',
            robot: 'radial-gradient(circle, rgba(79,172,254,0.8) 0%, rgba(0,242,254,0.4) 100%)',
            sunburst: 'radial-gradient(circle, rgba(254,225,64,0.9) 0%, rgba(250,112,154,0.5) 100%)',
            dashboard: 'radial-gradient(circle, rgba(48,207,208,0.8) 0%, rgba(51,8,103,0.4) 100%)',
            myroboeyes: 'radial-gradient(circle, rgba(147,112,219,0.8) 0%, rgba(186,85,211,0.4) 100%)' // Violet/Pourpre
        };
        
        function setExpression(expr) {
            currentExpression = expr;
            animFrame = 0;
            startTime = performance.now(); // R√©initialise le temps pour le simulateur
            ledRing.style.background = LED_COLORS[expr];
            moodLabel.textContent = `Expression: ${expr.toUpperCase()}`;
            
            // R√©initialiser l'√©tat sp√©cifique √† myroboeyes quand on change d'expression
            if (expr === 'myroboeyes') {
                initMyRoboEyes();
            }
        }
        
        // Helper: Rounded rectangle
        function roundRect(ctx, x, y, width, height, radius, fill) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            else ctx.stroke();
        }
        
        // Helper: Triangle
        function fillTriangle(ctx, x1, y1, x2, y2, x3, y3, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
        }

        // ========== EXPRESSION 1 : KAWAII (Yeux ronds) ==========
        function drawKawaii() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, 240, 240);
            
            // Animation clignement
            const blink = Math.sin(animFrame * 0.05) > 0.95;
            const eyeH = blink ? 8 : 56;
            
            // Yeux gauche et droite
            const eyeW = 56;
            const eyeY = 120 - eyeH / 2;
            
            ctx.fillStyle = COLORS.CREAM;
            
            // ≈íil gauche
            if (blink) {
                roundRect(ctx, 50, eyeY, eyeW, eyeH, 3, true);
            } else {
                ctx.beginPath();
                ctx.arc(50 + eyeW/2, 120, eyeW/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupille
                ctx.fillStyle = COLORS.BLACK;
                ctx.beginPath();
                ctx.arc(50 + eyeW/2, 120, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.fillStyle = COLORS.CREAM;
            // ≈íil droit
            if (blink) {
                roundRect(ctx, 134, eyeY, eyeW, eyeH, 3, true);
            } else {
                ctx.beginPath();
                ctx.arc(134 + eyeW/2, 120, eyeW/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupille
                ctx.fillStyle = COLORS.BLACK;
                ctx.beginPath();
                ctx.arc(134 + eyeW/2, 120, 15, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ========== EXPRESSION 2 : CYCLOPE (Un ≈ìil central) ==========
        function drawCyclope() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, 240, 240);
            
            // Animation pulsation
            const pulse = Math.sin(animFrame * 0.08) * 5;
            const radius = 60 + pulse;
            
            // Cercle principal
            const gradient = ctx.createRadialGradient(120, 120, 0, 120, 120, radius);
            gradient.addColorStop(0, COLORS.YELLOW);
            gradient.addColorStop(0.7, COLORS.CREAM);
            gradient.addColorStop(1, COLORS.ORANGE);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(120, 120, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Reflet
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(110, 110, 20, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========== EXPRESSION 3 : ROBOT (Minimaliste) ==========
        function drawRobot() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, 240, 240);
            
            // Yeux rectangulaires
            ctx.fillStyle = COLORS.CYAN;
            roundRect(ctx, 60, 100, 40, 12, 4, true);
            roundRect(ctx, 140, 100, 40, 12, 4, true);
            
            // Barres lat√©rales (√©galiseur)
            const bars = 5;
            for (let i = 0; i < bars; i++) {
                const h = 10 + Math.sin(animFrame * 0.1 + i) * 8;
                roundRect(ctx, 20 + i * 6, 120 - h/2, 4, h, 2, true);
                roundRect(ctx, 210 + i * 6, 120 - h/2, 4, h, 2, true);
            }
            
            // Bouche
            ctx.strokeStyle = COLORS.CYAN;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(90, 150);
            ctx.lineTo(150, 150);
            ctx.stroke();
        }
        
        // ========== EXPRESSION 4 : SUNBURST (R√©veil) ==========
        function drawSunburst() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, 240, 240);
            
            // Cercle central
            const gradient = ctx.createRadialGradient(120, 120, 0, 120, 120, 40);
            gradient.addColorStop(0, COLORS.YELLOW);
            gradient.addColorStop(1, COLORS.ORANGE);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(120, 120, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // Rayons rotatifs
            const numRays = 16;
            const rotation = animFrame * 0.02;
            
            ctx.strokeStyle = COLORS.YELLOW;
            ctx.lineWidth = 4;
            
            for (let i = 0; i < numRays; i++) {
                const angle = (Math.PI * 2 / numRays) * i + rotation;
                const startR = 45;
                const endR = 70 + Math.sin(animFrame * 0.1 + i) * 8;
                
                ctx.beginPath();
                ctx.moveTo(120 + Math.cos(angle) * startR, 120 + Math.sin(angle) * startR);
                ctx.lineTo(120 + Math.cos(angle) * endR, 120 + Math.sin(angle) * endR);
                ctx.stroke();
            }
        }
        
        // ========== EXPRESSION 5 : DASHBOARD (Stats) ==========
        function drawDashboard() {
            ctx.fillStyle = '#001a33';
            ctx.fillRect(0, 0, 240, 240);
            
            // Titre
            ctx.fillStyle = COLORS.CYAN;
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('STATS', 120, 40);
            
            // Valeurs anim√©es
            const speed = Math.floor(Math.sin(animFrame * 0.05) * 30 + 70);
            const rpm = Math.floor(Math.sin(animFrame * 0.03) * 1000 + 2500);
            const temp = Math.floor(Math.sin(animFrame * 0.02) * 10 + 85);
            
            // Vitesse
            ctx.fillStyle = COLORS.YELLOW;
            ctx.font = 'bold 48px monospace';
            ctx.fillText(speed, 120, 100);
            ctx.font = '14px monospace';
            ctx.fillText('km/h', 120, 120);
            
            // RPM
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = 'bold 24px monospace';
            ctx.fillText(rpm, 120, 155);
            ctx.font = '12px monospace';
            ctx.fillStyle = '#888';
            ctx.fillText('RPM', 120, 172);
            
            // Temp
            ctx.fillStyle = COLORS.CYAN;
            ctx.font = 'bold 20px monospace';
            ctx.fillText(temp + '¬∞C', 120, 200);
            
            // Barre de progression (fuel)
            const fuel = (Math.sin(animFrame * 0.01) + 1) / 2;
            ctx.fillStyle = '#333';
            roundRect(ctx, 40, 215, 160, 12, 6, true);
            ctx.fillStyle = fuel > 0.3 ? COLORS.CYAN : COLORS.ORANGE;
            roundRect(ctx, 40, 215, 160 * fuel, 12, 6, true);
        }
        
        // ========== EXPRESSION 6 : MON ROBOEYES (Fid√®le √† ton code) ==========
        // Variables d'√©tat pour cette expression sp√©cifique
        let my_eyeW = 56;
        let my_eyeH_Max = 56;
        let my_borderRadius = 16;
        let my_spaceBetween = 24;
        let my_blinkThickness = 6;
        let my_blinkWidth = 64;
        let my_blinkThreshold = 12.0;
        
        let my_curLx, my_curLy, my_curLh;
        let my_targetLx, my_targetLy, my_targetLh;
        
        const MY_MOODS = { NORMAL: 0, TIRED: 1, ANGRY: 2, HAPPY: 3 };
        let my_currentMood = MY_MOODS.NORMAL;
        
        let my_lastUpdateTime = 0;
        const my_frameInterval = 16; // 16ms = ~60 FPS
        
        let my_blinkTimer = 0;
        let my_idleTimer = 0;
        let my_moodTimer = 0;
        
        const MY_BGCOLOR = COLORS.BLACK;
        const MY_EYECOLOR = COLORS.WHITE;

        function initMyRoboEyes() {
            my_targetLh = my_eyeH_Max;
            my_targetLx = (240 - (my_eyeW * 2 + my_spaceBetween)) / 2;
            my_targetLy = (240 - my_eyeH_Max) / 2;
            
            my_curLx = my_targetLx;
            my_curLy = my_targetLy;
            my_curLh = my_eyeH_Max;
            
            my_blinkTimer = performance.now() + 2000;
            my_idleTimer = performance.now() + 4000;
            my_moodTimer = performance.now() + 4000;
            my_currentMood = MY_MOODS.NORMAL; // R√©initialiser √† NORMAL
            my_lastUpdateTime = performance.now();
        }

        function drawMyRoboEyes() {
            const now = performance.now();

            // La logique de mise √† jour des variables d'animation est appel√©e √† chaque frame,
            // mais l'ESP32 ne fait la mise √† jour que toutes les `my_frameInterval` (16ms).
            // Ici, on reproduit cela en conditionnant la mise √† jour des variables internes
            // tout en dessinant √† chaque `requestAnimationFrame` pour la fluidit√© du navigateur.
            if (now - my_lastUpdateTime >= my_frameInterval) {
                my_lastUpdateTime = now;

                // 1. Cycle des √©motions
                if (now > my_moodTimer) {
                    if (my_currentMood === MY_MOODS.NORMAL) my_currentMood = MY_MOODS.TIRED;
                    else if (my_currentMood === MY_MOODS.TIRED) my_currentMood = MY_MOODS.ANGRY;
                    else if (my_currentMood === MY_MOODS.ANGRY) my_currentMood = MY_MOODS.HAPPY;
                    else my_currentMood = MY_MOODS.NORMAL;
                    my_moodTimer = now + 4000;
                }

                // 2. Clignement (On cible 0 pour une fermeture compl√®te)
                if (now > my_blinkTimer) {
                    my_targetLh = 0;
                    my_blinkTimer = now + (Math.random() * (5000 - 2000) + 2000);
                }

                // 3. Mouvements
                if (now > my_idleTimer) {
                    my_targetLx = (Math.random() * (90 - 40) + 40);
                    my_targetLy = (Math.random() * (105 - 70) + 70);
                    my_idleTimer = now + (Math.random() * (6000 - 2000) + 2000);
                }

                // 4. Interpolation NERVEUSE (Plus rapide pour le clignement)
                const speed = (my_targetLh === 0 || my_curLh < 10) ? 0.40 : 0.20;
                my_curLx += (my_targetLx - my_curLx) * 0.20;
                my_curLy += (my_targetLy - my_curLy) * 0.20;
                my_curLh += (my_targetLh - my_curLh) * speed;
                
                // R√©ouverture imm√©diate d√®s que c'est ferm√©
                if (my_curLh < 1.0) my_targetLh = my_eyeH_Max;
            }
            
            // 5. DESSIN LOGIQUE
            ctx.fillStyle = MY_BGCOLOR;
            ctx.fillRect(0, 0, 240, 240);
            
            let drawW, drawH, drawRadius, finalY;
            let xL, xR;
            
            if (my_curLh < my_blinkThreshold) {
                // PHASE TRAIT : On affiche le trait fixe
                drawW = my_blinkWidth;
                drawH = my_blinkThickness;
                drawRadius = 3;
                finalY = Math.floor(my_curLy + (my_eyeH_Max / 2) - (my_blinkThickness / 2));
                xL = Math.floor(my_curLx - (my_blinkWidth - my_eyeW) / 2);
                xR = xL + my_blinkWidth + (my_spaceBetween - (my_blinkWidth - my_eyeW));
            } else {
                // PHASE NORMALE : L'oeil scale en hauteur normalement
                drawW = my_eyeW;
                drawH = Math.floor(my_curLh);
                drawRadius = my_borderRadius;
                finalY = Math.floor(my_curLy + (my_eyeH_Max - drawH) / 2); // Centrage vertical pendant le scale
                xL = Math.floor(my_curLx);
                xR = xL + my_eyeW + my_spaceBetween;
            }
            
            ctx.fillStyle = MY_EYECOLOR;
            roundRect(ctx, xL, finalY, drawW, drawH, drawRadius, true);
            roundRect(ctx, xR, finalY, drawW, drawH, drawRadius, true);

            // 6. √âMOTIONS (Seulement en mode normal)
            if (my_curLh >= my_blinkThreshold) {
                let mH = drawH / 2;
                if (my_currentMood === MY_MOODS.ANGRY) {
                    fillTriangle(ctx, xL, finalY, xL + my_eyeW, finalY, xL + my_eyeW, finalY + mH, MY_BGCOLOR);
                    fillTriangle(ctx, xR, finalY, xR + my_eyeW, finalY, xR, finalY + mH, MY_BGCOLOR);
                } else if (my_currentMood === MY_MOODS.TIRED) {
                    fillTriangle(ctx, xL, finalY, xL + my_eyeW, finalY, xL, finalY + mH, MY_BGCOLOR);
                    fillTriangle(ctx, xR, finalY, xR + my_eyeW, finalY, xR + my_eyeW, finalY + mH, MY_BGCOLOR);
                } else if (my_currentMood === MY_MOODS.HAPPY) {
                    // Note: Ton code utilise BGCOLOR pour masquer une partie des yeux, ce qui est reproduit ici.
                    roundRect(ctx, xL - 2, finalY + mH, my_eyeW + 4, my_eyeH_Max, my_borderRadius, true, MY_BGCOLOR);
                    roundRect(ctx, xR - 2, finalY + mH, my_eyeW + 4, my_eyeH_Max, my_borderRadius, true, MY_BGCOLOR);
                }
            }
        }

        // Boucle d'animation
        function animate() {
            animFrame++;
            
            switch(currentExpression) {
                case 'kawaii':
                    drawKawaii();
                    break;
                case 'cyclope':
                    drawCyclope();
                    break;
                case 'robot':
                    drawRobot();
                    break;
                case 'sunburst':
                    drawSunburst();
                    break;
                case 'dashboard':
                    drawDashboard();
                    break;
                case 'myroboeyes':
                    drawMyRoboEyes();
                    break;
            }
            
            requestAnimationFrame(animate);
        }
        
        // D√©marrage
        setExpression('myroboeyes'); // Commence par ton code fid√®le
        animate();
    </script>
</body>
</html>
